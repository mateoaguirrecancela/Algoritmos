AUTORES:
 - Martín Del Río Álvarez          martin.delrio.alvarez@udc.es
 - Mateo Aguirre Cancela           mateo.aguirre@udc.es
 
INTRODUCCIÓN:
	En esta práctica se llevarán a cabo diversas operaciones sobre montículos, con el objetivo de estudiar la complejidad de la operación "crear_monticulo" y demostrar que su ejecución tiene un tiempo O(n).
	Se implementará además el algoritmo de ordenación por montículos, y se procederá a calcular empíricamente su complejidad en tres contextos distintos: cuando se le suministra un vector ya ordenado de manera ascendente, cuando se le proporciona un vector ya ordenado de manera descendente, y cuando se le pasa un vector generado aleatoriamente.

TEST:
	Creamos un monticulo con el siguiente vector:
	[ -9  -5   0  -4   0   7   7   7   2   4 ]
	Eliminamos el elemento menor, quedando el siguiente monticulo:
	[ -5  -4   0   2   0   7   7   7   4 ]
	Comprobamos el funcionamiento de ordenacion por monticulos:
	[ -9  -5  -4   0   0   2   4   7   7   7 ]

ESPECIFIACIONES DE LA MÁQUINA:
	·Modelo: HUAWEI MateBook 14 AMD 2021
	·Procesador: AMD Ryzen 5 5500U
	·Memoria RAM: 8gb
	·Sistema operativo: Linux Ubuntu 22.04.3 LTS
	·Kernel: 6.2.0-33-generic

ACLARACIONES:
	Todas las unidades de tiempo estan medidas en microsegundos.
	El valor de n sigue una progresión geométrica de razón dos.
	Los símbolos (*) colocados a la izquierda de ciertos tiempos indican que el tiempo de ejecución para ese valor de n es inferior a 500 microsegundos. Esto implica que el algoritmo se repitió 1000 (contante K) veces y posteriormente se calculó una media.

TABLAS DE TIEMPOS:

VECTOR EN ORDEN ASCENDENTE
             n             t(n)        t(n)/n^0.92     t(n)/n*log(n)   t(n)/n^1.4
(*)        500        35.925000        0.118126        0.011561        0.005982
(*)       1000        95.622000        0.166172        0.013843        0.006033
(*)       2000       223.411000        0.205190        0.014696        0.005341
(*)       4000       486.645000        0.236220        0.014668        0.004409
          8000      1056.000000        0.270908        0.014688        0.003625
         16000      2196.000000        0.297743        0.014178        0.002857
         32000      4648.000000        0.333064        0.014002        0.002291
         64000      9798.000000        0.371067        0.013834        0.001830
        128000     21790.000000        0.436138        0.014476        0.001542

-COTAS:
	cota subestimada:  n^0.92
	cota ajustada:     n*log(n)
	cota sobrestimada: n^1.4

(#) ANOMALIAS:
	-Se puede observar una ligera anomalía para n=500 (#), la cual no se ha podido impedir que se desvíe ligeramente del valor aproximado de la cota ajustada.

-OBSERVACIONES:
	-Los resultados de la cota subestimada nos ofrece unos valores ascendentes.
	-Al contrario ocurre con la sobrestimada, pues estos decrecen.
	-La cota ajustada se aproxima ???

VECTOR EN ORDEN DESCENDENTE
             n             t(n)        t(n)/n^0.92     t(n)/n*log(n)   t(n)/n^1.4
(*)        500        44.008000        0.144704        0.014163        0.007328
(*)       1000       103.049000        0.179079        0.014918        0.006502
(*)       2000       238.466000        0.219018        0.015687        0.005701
          4000       530.000000        0.257265        0.015975        0.004802
          8000      1111.000000        0.285017        0.015453        0.003814
         16000      2267.000000        0.307370        0.014637        0.002949
         32000      4824.000000        0.345676        0.014532        0.002378
         64000     10078.000000        0.381671        0.014229        0.001882
        128000     20895.000000        0.418224        0.013881        0.001479

-COTAS:
	cota subestimada:  n^0.92
	cota ajustada:     n*log(n)
	cota sobrestimada: n^1.4

(#) ANOMALIAS:
	-Se puede observar una ligera anomalía para n=1000, para n=2000 y para n=8000 (#), las cuales no se han podido impedir que se desvíen ligeramente del valor aproximado de la cota ajustada.

-OBSERVACIONES:
	-Los resultados de la cota subestimada nos ofrece unos valores ascendentes.
	-Al contrario ocurre con la sobrestimada, pues estos decrecen.
	-La cota ajustada se aproxima ???

VECTOR EN ORDEN ALEATORIO
             n             t(n)        t(n)/n^0.92     t(n)/n*log(n)   t(n)/n^1.4
(*)        500        59.432000        0.195420        0.019127        0.009896
(*)       1000       130.336000        0.226498        0.018868        0.008224
(*)       2000       277.420000        0.254795        0.018249        0.006633
          4000       628.000000        0.304835        0.018929        0.005690
          8000      1298.000000        0.332991        0.018053        0.004456
         16000      2796.000000        0.379094        0.018052        0.003637
         32000      6004.000000        0.430232        0.018087        0.002960
         64000     12813.000000        0.485250        0.018091        0.002393
        128000     27350.000000        0.547424        0.018170        0.001936

-COTAS:
	cota subestimada:  n^0.92
	cota ajustada:     n*log(n)
	cota sobrestimada: n^1.4

(#) ANOMALIAS:
	-Se puede observar una ligera anomalía para n=500 (#), la cual no se ha podido impedir, que se desvía ligeramente del valor aproximado de la cota ajustada.

-OBSERVACIONES:
	-Los resultados de la cota subestimada nos ofrece unos valores ascendentes.
	-Al contrario ocurre con la sobrestimada, pues estos decrecen.
	-Y la cota ajustada se aproxima 0.018

CONCLUSIONES:


#Poner debajo de cada tabla la cota subestimada, la cota real y la cota sobrestimada
#Poner a que constante se aproxima la cota real
#Indicar que significa el asterisco en las tablas de tiempo (arreglo de tiempos pequeños)
#Ampliar conclusión (Las dos primeras lineas de la conclusión de la P2 no son conclusiones) & Si hay varios algoritmos comparar ese mismo algoritmo en todas sus situaciones
#INDICAR las cotas anómalas
